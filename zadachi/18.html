<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Сортировка массивов и файлов*</title>
</head>
<body>
<h2>§18. Сортировка массивов и файлов *)</h2>
<ol start='628'>
<li>Рассмотрим массив целых или действительных чисел 
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
</math>. 
Пусть требуется переставить элементы этого массива так, чтобы после перестановки они были упорядочены по неубыванию:
<math>
	<msub><mi>a</mi><mn>1</mn></msub><mi>&#8804;</mi>
	<msub><mi>a</mi><mn>2</mn></msub><mi>&#8804;</mi>
	<mi>&#133;</mi><mi>&#8804;</mi>
	<msub><mi>a</mi><mi>n</mi></msub>
</math>. 
Эта задача называется задачей сортировки или упорядочения массива (эту же задачу можно рассматривать применительно к упорядочению по невозрастанию:  
<math>
	<msub><mi>a</mi><mn>1</mn></msub><mi>&#8805;</mi>
	<msub><mi>a</mi><mn>2</mn></msub><mi>&#8805;</mi>
	<mi>&#133;</mi><mi>&#8805;</mi>
	<msub><mi>a</mi><mi>n</mi></msub>
</math>;
если числа попарно различны, то можно говорить об убывании и о возрастании). Для решения этой задачи можно воспользоваться, например, следующими алгоритмами: 
<ol type='a'>
<li>Найти элемент массива, имеющий наименьшее значение, переставить  его с первым элементом, затем проделать то же самое, начав со второго элемента и т. д. (Сортировка выбором.)
 </li>
 <li>Последовательным просмотром чисел 
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
</math>
найти наименьшее <math><mi>i</mi></math> такое, что 
<math>
	<msub><mi>a</mi><mi>i</mi></msub>
	<mi>&#62;</mi>
	<msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub>
</math>. Поменять <math><msub><mi>a</mi><mi>i</mi></msub></math> и
<math><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></math>
местами, возобновить просмотр с элемента
<math><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></math>
и т. д. Тем самым наибольшее число передвинется на последнее место. Следующие просмотры начинать опять сначала, уменьшая на единицу количество просматриваемых элементов. Массив будет упорядочен после просмотра, в котором участвовали только первый и второй элементы. (Сортировка обменами.)
</li>
<li>Просматривать последовательно 
<math>
	<msub><mi>a</mi><mn>2</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
</math>
и каждый новый элемент <math><msub><mi>a</mi><mi>i</mi></msub></math> вставлять на подходящее место в уже упорядоченную совокупность
<math>
<msub><mi>a</mi><mi>i</mi></msub><mo>,</mo><mi>&#133;</mi><mo>,</mo>
<msub><mi>a</mi><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub>
</math>.
Это место определяется последовательным сравнением 
<math><msub><mi>a</mi><mi>i</mi></msub></math> с упорядоченными элементами 
<math><msub><mi>a</mi><mi>i</mi></msub><mo>,</mo>
<msub><mi>a</mi><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub>
</math>. (Сортировка простыми вставками).</li>
 <p>Написать программы, реализующие алгоритмы a), b), c). </p>
 </li>
</ol> 
 <li>Исследовать число сравнений и число перемещений (т. е. перестановок с одного места на другое) элементов 
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
</math> в процессе применения описанных в предыдущей задаче алгоритмов. Показать, что число перемещений для алгоритма сортировки выбором ограничено некоторой линейной функцией от <math><mi>n</mi></math>. Число сравнений для алгоритма сортировки выбором и обе указанные характеристики для алгоритмов сортировки обменами и сортировки простыми вставками в некоторых случаях (например, когда исходный массив таков, что
<math>
	<msub><mi>a</mi><mn>1</mn></msub><mi>&#62;</mi><msub><mi>a</mi><mn>2</mn></msub>
	<mi>&#62;</mi><mi>&#133;</mi><mi>&#62;</mi>
	<msub><mi>a</mi><mi>n</mi></msub>
</math>
) являются квадратичными функциями от <math><mi>n</mi></math>.
 </li>
 <li>Из утверждения предыдущей задачи следует, что алгоритм сортировки выбором выгодно отличается от алгоритмов сортировки обменами и сортировки простыми вставками в тех случаях, когда перемещение элемента оказывается существенно более сложным делом, чем сравнение элементов. Использовать это при выполнении следующих заданий.</p>
 <p>
 Дана действительная матрица размера
 <math>
<mi>n</mi><mi>&#10005;</mi><mi>m</mi><mo>;</mo></math>
упорядочить (переставить) строки матрицы:
 </p>
 <ol type='a'>
 <li>по неубыванию значений первых элементов строк;</li> 
 <li>по невозрастанию сумм элементов строк; </li>
 <li>по неубыванию значений наименьших элементов строк; </li>
 <li>по невозрастанию значений наибольших элементов строк.</li>
 </ol>
 <p>В заданиях b), c), d) разрешается дополнительно определить числовой массив 
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
</math>.
 </li>
 <li>Пусть дан упорядоченный по неубыванию массив целых или действительных чисел
<math>
	<msub><mi>a</mi><mn>1</mn></msub><mi>&#8804;</mi>
	<msub><mi>a</mi><mn>2</mn></msub><mi>&#8804;</mi>
	<mi>&#133;</mi><mi>&#8804;</mi>
	<msub><mi>a</mi><mi>n</mi></msub>
</math> и пусть дано некоторое число <math><mi>b</mi></math> (соответственно целое или действительное), для которого нужно найти такое место среди чисел 
<math>
	<msub><mi>a</mi><mn>1</mn></msub><mi>&#8804;</mi>
	<msub><mi>a</mi><mn>2</mn></msub><mi>&#8804;</mi>
	<mi>&#133;</mi><mi>&#8804;</mi>
	<msub><mi>a</mi><mi>n</mi></msub>
</math>, чтобы после вставки числа <math><mi>b</mi></math> на это место упорядоченность не нарушилась. Если вследствие равенства между собой некоторых элементов массива число <math><mi>b</mi></math> можно вставлять на разные места, то требуется определить ближайшее к началу массива место. Эта задача называется задачей поиска места элемента. Для <math><mi>b</mi></math> имеется 
<math><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></math> возможность:
<math>
	<mi>b</mi><mi>&#8804;</mi><msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo>
	<msub><mi>a</mi><mn>1</mn></msub><mi>&#60;</mi><mi>b</mi>
 	<mi>&#8804;</mi>
	<msub><mi>a</mi><mn>2</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub>
	<mi>&#60;</mi><mi>b</mi><mi>&#8804;</mi>
	<msub><mi>a</mi><mi>n</mi></msub>
	<mo>,</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
	<mi>&#60;</mi><mi>b</mi>
</math>,
и решением задачи поиска места элемента <math><mi>b</mi></math> будет соответственно одно из чисел   
<math><mn>1</mn><mo>,</mo><mi>&#133;</mi><mo>,</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></math>.
Для решения задачи полезен алгоритм, который называется алгоритмом деления пополам: взять первоначально 
<math><mn>1</mn></math> и <math><mi>n</mi><mo>+</mo><mn>1</mn></math> в качестве границ поиска места элемента; далее, до тех пор, пока границы не совпадут, шаг за шагом сдвигать эти границы следующим образом: сравнить <math><mi>b</mi></math> с
<math><msub><mi>a</mi><mi>s</mi></msub></math>, где <math><mi>s</mi></math> &#151; целая часть среднего арифметического границ; если
<math><msub><mi>a</mi><mi>s</mi></msub><mi>&#60;</mi><mi>b</mi></math>, то заменить прежнюю нижнюю границу на 
<math><mi>s</mi><mo>+</mo><mn>1</mn></math>, а верхнюю оставить без изменения, иначе оставить без изменения нижнюю границу, а верхнюю заменить на <math><mi>s</mi></math>; когда границы совпадут, став равными некоторому числу
<math><mi>t</mi></math>, выполнение вышеописанного алгоритма закончится с результатом 
<math><mi>t</mi></math>. (Число сравнений, требуемых этим алгоритмом, не превосходит 
<math><mo>&#91;</mo><msub><mi>log</mi><mn>2</mn></msub>
<mo>&#40;</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo>&#41;</mo>
<mo>&#93;</mo> 
<mo>+</mo><mn>1</mn>
</math>).
 </li>
 <ol type='a'>
<li>Даны действительные числа
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
	<mo>,</mo><msub><mi>b</mi><mi>m</mi></msub>
	<mi>&#40;</mi> 
	<msub><mi>a</mi><mn>1</mn></msub>
	<mi>&#8804;</mi>
	<msub><mi>a</mi><mn>2</mn></msub>
	<mi>&#8804;</mi><mi>&#133;</mi><mi>&#8804;</mi>
	<msub><mi>a</mi><mi>n</mi></msub>
	<mi>&#41;</mi> 	
</math>.
Получить натуральные числа
<math>
	<msub><mi>k</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>k</mi><mi>m</mi></msub>
</math>
такие, что
<math><msub><mi>k</mi><mi>i</mi></msub></math> &#151; это решение задачи поиска места
<math><msub><mi>b</mi><mi>i</mi></msub></math>
среди 
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
	<mi>&#40;</mi>	<mi>i</mi><mo>&#61;</mo><mn>1</mn>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<mi>m</mi>
	<mi>&#41;</mi>
</math>.
Применить алгоритм деления пополам. </li>
 <li>Таблица выигрышей денежной лотереи представлена массивом выигравших номеров 
<math>
	<msub><mi>a</mi><mn>1</mn></msub><mi>&#8804;</mi>
	<msub><mi>a</mi><mn>2</mn></msub><mi>&#8804;</mi>
	<mi>&#133;</mi><mi>&#8804;</mi>
	<msub><mi>a</mi><mi>n</mi></msub>
</math> и массивом выигрышей в рублях
<math>
	<msub><mi>p</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>p</mi><mi>n</mi></msub>
	<mo>(</mo>
	<msub><mi>p</mi><mi>i</mi></msub>
</math> &#151; это выигрыш, выпавший на номер 
<math>
	<msub><mi>a</mi><mi>i</mi></msub><mi>&#40;</mi>
	<mi>i</mi><mo>&#61;</mo><mn>1</mn>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<mi>n</mi>
	<mo>)</mo>
	<mo>)</mo>
</math>.
Определить суммарный выигрыш, выпавший на билеты с номерами
<math>
	<msub><mi>b</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>b</mi><mi>m</mi></msub>
</math>.
Применить алгоритм деление пополам.
 </li>
 <li>Пусть место некоторого числа
<math><mi>b</mi></math> среди упорядоченных по неубыванию
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
</math>
выбирается как наиболее удаленное от начала последовательности место, на которое можно вставить это число, не нарушая этим упорядоченности по неубыванию. Внести изменение в описание алгоритма деления пополам и соответственно дать новое решение задания а), сформулированного выше.</li>
 </ol>
 </li>
 <li>Даны действительные числа
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
	<mo>,</mo>
	<mi>p</mi>
</math>, натуральное число
<math><mi>k</mi><mi>&#40;</mi> 
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>&#8804;</mo>
	<msub><mi>a</mi><mn>2</mn></msub>
	<mo>&#8804;</mo><mi>&#133;</mi><mo>&#8804;</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
	<mo>,</mo><mi>k</mi><mo>&#8804;</mo><mi>n</mi><mi>&#41;</mi>
</math>.
Удалить из
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
</math>
элемент с номером
<math><mi>k</mi></math> (т. е. <math><msub><mi>a</mi><mi>k</mi></msub></math>) и вставить элемент, равный <math><mi>p</mi></math>, так, чтобы не нарушилась упорядоченность. 
 </li>
 <li>Алгоритм упорядочения простыми вставками (см. алгоритм в задаче 628) можно изменить следующим образом: место, на которое надо вставить
 <math><msub><mi>a</mi><mi>i</mi></msub></math>  в уже упорядоченную совокупность
 <math>
 	<msub><mi>a</mi><mi>i</mi></msub>
 	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
 	<msub><mi>a</mi><mrow><mi>i</mi><mo>-</mo><mn>1</mn></mrow></msub>
 </math>
  , определяется алгоритмом деления пополам (см. задачу 631). Получится новый алгоритм сортировки, который называется алгоритмом сортировки бинарными вставками (слова &quot;бинарная вставка&quot; следует понимать как &quot;вставка делением пополам&quot;). Этот алгоритм требует всего около
 <math>
 	<mi>n</mi><mo>&#x2062;</mo><msub><mi>log</mi><mn>2</mn></msub><mrow><mo>&#x2061;</mo><mi>n</mi></mrow>
 </math>
 сравнением элементов. Написать программу, реализующую этот алгоритм. 
 </li>
 <li>Даны целые числа
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
</math>.
Получить в порядке возрастания все различные числа, входящие в
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
</math>.
Здесь удобно воспользоваться алгоритмом сортировки вставками (если <math><mi>n</mi></math> велико, то лучше применить бинарные вставки; если <math><mi>n</mi></math> сравнительно мало, скажем,
<math><mi>n</mi><mi>&#60;</mi><mn>50</mn></math>, то можно обойтись и простыми вставками). В процессе сортировки следует отбрасывать элементы, уже встречавшиеся раньше. Если в результате поиска места <math><msub><mi>a</mi><mi>i</mi></msub></math>
в упорядоченной совокупности
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>k</mi></msub>
	<mo lspace="0.5em">(</mo>
	<mi>k</mi>
	<mi>&#60;</mi>
	<mi>i</mi>
	<mi>&#41;</mi>
</math> обнаружится, что среди
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>k</mi></msub>
</math>
есть элемент, равный
<math><msub><mi>a</mi><mi>i</mi></msub></math>, то следует перейти к рассмотрению
<math><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></math> без изменения 
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>k</mi></msub>
</math>.
 </p>
 <li>Даны действительные числа
<math>
<msub><mi>c</mi><mn>1</mn></msub>
<mo>,</mo><mi>&#133;</mi><mo>,</mo>
<msub><mi>c</mi><mi>p</mi></msub>
<mo>,</mo>
<msub><mi>d</mi><mn>1</mn></msub>
<mo>,</mo><mi>&#133;</mi><mo>,</mo>
<msub><mi>d</mi><mi>g</mi></msub>
<mo lspace="0.5em">(</mo>
<msub><mi>c</mi><mn>1</mn></msub>
<mo>&#8804;</mo>
<msub><mi>c</mi><mn>2</mn></msub>
<mo>&#8804;</mo><mi>&#133;</mi><mo>&#8804;</mo>
<msub><mi>c</mi><mi>p</mi></msub>
<mo>,</mo>
<msub><mi>d</mi><mn>1</mn></msub>
<mo>&#8804;</mo>
<msub><mi>d</mi><mn>2</mn></msub>
<mo>&#8804;</mo><mi>&#133;</mi><mo>&#8804;</mo>
<msub><mi>d</mi><mi>g</mi></msub>
<mi>&#41;</mi>
</math>.  Внести единую упорядоченность в 
<math> 
	<msub><mi>c</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>c</mi><mi>p</mi></msub>
	<mo>,</mo>
	<msub><mi>d</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>d</mi><mi>g</mi></msub>
</math>, получив
<math> 
	<msub><mi>f</mi><mn>1</mn></msub>
	<mo>,</mo>
	<msub><mi>f</mi><mn>2</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>f</mi><mrow><mi>p</mi><mo>+</mo><mi>g</mi></mrow></msub>
</math> такие, что 
<math> 
<msub><mi>f</mi><mn>1</mn></msub>
<mo>&#8804;</mo>
<msub><mi>f</mi><mn>2</mn></msub>
<mo>&#8804;</mo><mi>&#133;</mi><mo>&#8804;</mo>
<msub><mi>f</mi><mrow><mi>p</mi><mo>+</mo><mi>g</mi></mrow></msub>
</math>.
Число сравнений не должно превосходить <math><mi>p</mi><mo>+</mo><mi>g</mi></math>.
 </li>
 <li>Алгоритм фон Неймана упорядочения массива
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
</math> 
по неубыванию (алгоритм сортировки слияниями) основан на многократных слияниях уже упорядоченных групп элементов массива (см. предыдущую задачу). В начале весь массив рассматривается как совокупность упорядоченных групп по одному элементу в каждом. Слиянием соседних групп получаем упорядоченные группы, каждая из которых содержит два элемента (кроме, может быть, последней группы, которой не нашлось парной). Далее, упорядоченные группы укрупняются тем же способом и т. д. Здесь приходится оперировать не только с массивом 
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
</math>, но и с вспомогательным массивом 
<math>
	<msub><mi>b</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>b</mi><mi>n</mi></msub>
</math> 
(первоначальные значения его элементов не играют роли). Рис. 34 демонстрирует два последовательных этапа укрупнения: массивы
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
</math> 
и 
<math>
	<msub><mi>b</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>b</mi><mi>n</mi></msub>
</math> 
представлены в виде отрезков, которые разбиты на части, изображающие упорядоченные группы. Число упорядоченных групп убывает, следовательно, настанет такой момент, когда в массиве
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
</math> 
или
<math>
	<msub><mi>b</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>b</mi><mi>n</mi></msub>
</math> 
будет содержаться только одна упорядоченная группа. А это означает, что массив упорядочен. Для слияния двух упорядоченных групп, содержащих соответственно
<math> <mi>p</mi></math> и  <math> <mi>g</mi></math> элементов, достаточно произвести не более <math> <mi>p</mi><mo>+</mo><mi>g</mi></math>  сравнений. Следовательно, для одного этапа укрупнения достаточно произвести не более <math><mi>n</mi></math> сравнений. Столько же требуется на одном этапе и перемещений. Можно показать, что алгоритм фон Неймана требует в целом приблизительно 
<math>
	<mi>n</mi><mo>&#x2062;</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>&#x2061;</mo><mi>n</mi></mrow>
</math>
 сравнений и столько же перемещений. Из рассмотренных до сих пор алгоритмов только алгоритм сортировки бинарными вставками требовал столь небольшого числа сравнений. Однако алгоритм фон Неймана выгодно отличается от последнего алгоритма тем, что требует меньше перемещений элементов 
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
</math> 
(хотя и требует дополнительного массива
<math>
	<msub><mi>b</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>b</mi><mi>n</mi></msub>
</math>). Написать программу, реализующую алгоритм фон Неймана. 

<svg width="860" height="160" xmlns="http://www.w3.org/2000/svg">
 <!-- Created with SVG-edit - http://svg-edit.googlecode.com/ -->
 <g>
  <title>Layer 1</title>
  <line id="svg_1" y2="18" x2="140" y1="18" x1="14" stroke="#000000" fill="none"/> 
  <path fill=" none" d="m14,18c6,27 36,2 61,27"/>
  <path fill=" none" d="m75,45c15,-20 55,-2 65,-27"/>
  <line fill="none" stroke="#000000" x1="14" y1="14" x2="14" y2="22" id="svg_2"/> 
  <line fill="none" stroke="#000000" x1="140" y1="14" x2="140" y2="22" id="svg_3"/>
  <line id="svg_4" y2="18" x2="262" y1="18" x1="140" stroke="#000000" fill="none"/>
  <line fill="none" stroke="#000000" x1="262" y1="14" x2="262" y2="22" id="svg_5"/>
  <line id="svg_6" y2="18" x2="388" y1="18" x1="262" stroke="#000000" fill="none"/>
  <line id="svg_7" y2="22" x2="388" y1="14" x1="388" stroke="#000000" fill="none"/>
  <path fill=" none" d="m140,18c6,27 90,2 122,27"/>
  <path fill=" none" d="m262,45c23,-20 116,-2 126,-27"/> 
  <line fill="none" stroke="#000000" x1="75" y1="49" x2="75" y2="120" id="svg_8"/>
  <line id="svg_9" y2="106" x2="81" y1="120" x1="75" stroke="#000000" fill="none"/>
  <line id="svg_11" y2="106" x2="69" y1="120" x1="75" stroke="#000000" fill="none"/>
  <line fill="none" stroke="#000000" x1="262" y1="49" x2="262" y2="120" id="svg_12"/>
  <line id="svg_13" y2="106" x2="268" y1="120" x1="262" stroke="#000000" fill="none"/>
  <line id="svg_14" y2="106" x2="256" y1="120" x1="262" stroke="#000000" fill="none"/> 
  <line fill="none" stroke="#000000" x1="14" y1="121" x2="140" y2="121" id="svg_15"/>
  <line id="svg_16" y2="125" x2="14" y1="117" x1="14" stroke="#000000" fill="none"/>
  <line id="svg_17" y2="125" x2="140" y1="117" x1="140" stroke="#000000" fill="none"/> 
  <line fill="none" stroke="#000000" x1="140" y1="121" x2="388" y2="121" id="svg_18"/>
  <line id="svg_19" y2="125" x2="388" y1="117" x1="388" stroke="#000000" fill="none"/>
  <path id="svg_20" d="m14,20c1,41.6667 60,-7.6667 62,19" stroke="#000000" fill="none"/>
  <path id="svg_24" d="m76,38c4.3334,-23.3333 64.66701,22.3333 64,-19" stroke="#000000" fill="none"/>
  <path id="svg_25" d="m140,19c-1.66701,48.6667 123.66699,-10.66666 121,17" stroke="#000000" fill="none"/>
  <path id="svg_27" d="m384,17l-15,25" fill=" none"/>
  <path id="svg_28" d="m388,19c-3.33301,46 -132.66701,-8 -127,18" stroke="#000000" fill="none"/> 
  <path id="svg_29" d="m261,37" opacity="0.5" stroke="#000000" fill="none"/>
  <line fill="none" stroke="#000000" x1="442" y1="18" x2="816" y2="18" id="svg_30"/>
  <line id="svg_31" y2="22" x2="442" y1="14" x1="442" stroke="#000000" fill="none"/>
  <line id="svg_32" y2="22" x2="816" y1="14" x1="816" stroke="#000000" fill="none"/>
  <line id="svg_33" y2="22" x2="569" y1="14" x1="569" stroke="#000000" fill="none"/>
  <line id="svg_34" y2="22" x2="691" y1="14" x1="691" stroke="#000000" fill="none"/> 
  <line fill="none" stroke="#000000" x1="505" y1="23" x2="505" y2="93" id="svg_35"/>
  <line fill="none" stroke="#000000" x1="630" y1="23" x2="630" y2="93" id="svg_36"/>
  <line fill="none" stroke="#000000" x1="754" y1="23" x2="754" y2="93" id="svg_37"/>
  <line id="svg_38" y2="36" x2="500" y1="23" x1="505" stroke="#000000" fill="none"/>
  <line id="svg_39" y2="36" x2="510" y1="23" x1="505" stroke="#000000" fill="none"/>
  <line id="svg_40" y2="36" x2="625" y1="23" x1="630" stroke="#000000" fill="none"/> 
  <line id="svg_41" y2="36" x2="635" y1="23" x1="630" stroke="#000000" fill="none"/>
  <line fill="none" stroke="#000000" x1="754" y1="23" x2="749" y2="36" id="svg_42"/>
  <line fill="none" stroke="#000000" x1="754" y1="23" x2="759" y2="36" id="svg_43"/>
  <line id="svg_44" y2="124" x2="816" y1="124" x1="442" stroke="#000000" fill="none"/>
  <line id="svg_46" y2="127" x2="442" y1="121" x1="442" stroke="#000000" fill="none"/>
  <line id="svg_47" y2="127" x2="569" y1="121" x1="569" stroke="#000000" fill="none"/> 
  <line id="svg_48" y2="127" x2="691" y1="121" x1="691" stroke="#000000" fill="none"/>
  <line id="svg_49" y2="127" x2="816" y1="121" x1="816" stroke="#000000" fill="none"/>
  <line fill="none" stroke="#000000" x1="505" y1="121" x2="505" y2="127" id="svg_50"/>
  <line fill="none" stroke="#000000" x1="630" y1="121" x2="630" y2="127" id="svg_51"/>
  <line fill="none" stroke="#000000" x1="754" y1="121" x2="754" y2="127" id="svg_65"/>
  <path fill="none" stroke="#000000" d="m442,125c8,-33.6666 52,1.667 62,-24" id="svg_52"/> 
  <path fill="none" stroke="#000000" d="m503,102c8,25.333 58,-11.3333 66,22" id="svg_55"/>
  <path fill="none" stroke="#000000" d="m568,124c6.66699,-34 56.33301,5 62,-21" id="svg_56"/>
  <path fill="none" stroke="#000000" d="m691,123c1.66699,-34.6666 -58.66699,6.66701 -61,-20" id="svg_58"/>
  <path fill="none" stroke="#000000" d="m754,102c-4.33301,23.333 -61.66699,-17.3333 -64,22" id="svg_60"/>
  <path fill="none" stroke="#000000" stroke-width="0.5" d="m816,123c-2,-39.6666 -58,3.667 -63,-20" id="svg_63"/>
  <path fill="none" stroke="#000000" stroke-width="0.5" opacity="0.5" d="m753,102" id="svg_64"/>
  <text x="370" y="150" stroke="#000000">Рис. 34</text>
 </g>
</svg>
 </li>
 <li>Пусть дан массив
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
</math>.
 Требуется переставить
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
</math> так, чтобы вначале в массиве шла группа элементов, больших того элемента, который в исходном массиве располагается на первом месте, затем &#151; сам этот элемент, потом &#151; группа элементов, меньших или равных ему. Число сравнений и перемещений, каждое в отдельности, не должно превышать <math><mi>n</mi><mo>-</mo><mn>1</mn></math>.
</li>
<li>На преобразовании массива, описанном в предыдущей задаче, основывается следующий рекурсивный алгоритм сортировки (так называемая быстрая сортировка). Если массив содержит не более одного элемента, то он упорядочен. Иначе применяем к нему преобразование, описанное в предыдущей задаче, и определяем результат применения алгоритма быстрой сортировки к 
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
</math>
следующим образом: вначале идет первая группа элементов, упорядоченная с помощью алгоритма быстрой сортировки, затем без изменения тот элемент, который разделял первую и вторую группы элементов, затем вторая группа элементов, упорядоченная с помощью алгоритма быстрой сортировки. Этот алгоритм не использует дополнительного массива и требует в среднем приблизительно <math><mi>n</mi><mo>&#x2062;</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>&#x2061;</mo><mi>n</mi></mrow></math> сравнений и столько же перемещений элементов. Правда, это лишь среднее число: в худшем случае число сравнений может достигать
<math>
	<mi>n</mi><mo>&#x2062;</mo><mo>(</mo><mi>n</mi><mo>-</mo><mn>1</mn><mo>)</mo><mn>/</mn><mn>2</mn>
</math>; кроме того, алгоритм быстрой сортировки содержит рекурсии.
<p> Написать программу, реализующую алгоритм быстрой сортировки.</p>
</li> 
<li>На преобразовании массива, описанном в задаче 637, основывается также следующий алгоритм поиска значения <math><mi>k</mi></math>-го по величине элемента массива
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
</math> (т. е. того элемента, который бы занял место с номером <math><mi>k</mi></math> после упорядочения массива). Пусть в результате преобразования, описанного в задаче 637, первый элемент занял <math><mi>p</mi></math>-е место; если <math><mi>k</mi><mo>=</mo><mi>p</mi></math>, то поиск закончен; если <math><mi>k</mi><mo>&#60;</mo><mi>p</mi></math>, то надо перейти к поиску <math><mi>k</mi></math>-го по величине элемента в начальной группе элементов, содержащей <math><mi>p</mi><mo>-</mo><mn>1</mn></math> элемент. Задача упростилась, так как <math><mrow><mi>p</mi><mo>-</mo><mn>1</mn></mrow><mo>&#60;</mo><mi>n</mi></math>, если же <math><mi>k</mi><mn>&#62;</mn><mi>p</mi></math>, то надо перейти к поиску
<math><mo>(</mo><mi>k</mi><mo>-</mo><mi>p</mi><mo>)</mo></math>-го по величине элемента во второй группе элементов (задача упростилась, так как 
<math><mi>n</mi><mo>-</mo><mn>p</mn><mo>&#60;</mo><mi>n</mi><mo>)</mo></math>. Этот алгоритм не содержит рекурсий. Не пользуясь рекурсиями, написать программу, реализующую этот алгоритм.
</li>
<li>Нетрудно заметить, что алгоритм, описанный в предыдущей задаче, фактически позволяет найти не только 
<math><mi>k</mi></math>-й по величине элемент, но и дополнительно 1-ый, 2-ой, &#133;, <math><mo>(</mo><mi>k</mi><mo>-</mo><nm>1</mn><mo>)</mo></math>-ый элементы, хотя и в неупорядоченном виде. Основываясь на этом, выполнить следующие задания:
<ol type='a'>
<li>В массиве
<math> 
	<msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mrow><mrow><mn>2</mn><mi>m</mi></mrow><mo>+</mo><mn>1</mn></mrow></msub>
</math> найти
<math><mo>(</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo>)</mo></math>-й по величине элемент (это так называемая медиана массива 
<math> 
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mrow><mrow><mn>2</mn><mi>m</mi></mrow><mo>+</mo><mn>1</mn></mrow></msub>
</math>) и группу элементов с первыми <math> <mi>m</mi></math> значениями;</li>
<li>Вновь решить задачу 170, положив для этого <math><mi>k</mi><mo>=</mo><mn>4</mn></math>.</li>
</ol>
</li>
<li>Алгоритм сортировки обменами (см. алгоритм b) в задаче 628) также имеет свои достоинства. Рассмотрим следующий пример. Пусть слова, которые можно выделить в массиве символов
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
</math> (см. задачу 269), требуется представить в лексикографическом порядке. Так как разные слова могут иметь разную длину, то без больших затруднений можно менять местами только слова, стоящие рядом. Но алгоритм сортировки обменами и предписывает только такие обмены. Эта задача не является, конечно, задачей сортировки массива, но тем не менее алгоритм сортировки обменами оказывается здесь полезным. Написать программу, предполагая, что длина слова не превосходит пятнадцати.</li>
<li>Алгоритм b), сформулированный в задаче 628 , &#151; это, строго говоря, лишь один из алгоритмов сортировки обменами. Он иногда называется алгоритмом пузырька. Есть и другие алгоритмы, которые естественно отнести к алгоритмам сортировки обменами. Приведем пример такого алгоритма. Последовательным просмотром чисел 
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
</math> найти наименьшее <math><mi>i</mi></math> такое, что 
<math> 
<msub><mi>a</mi><mn>i</mn></msub><mo>&#62;</mo><msub><mi>a</mi><mrow><mn>i</mn><mo>+</mo><mn>1</mn></mrow></msub></math>. Поменять
<math><msub><mi>a</mi><mn>i</mn></msub></math> и <math><msub><mi>a</mi><mrow><mn>i</mn><mo>+</mo><mn>1</mn></mrow></msub></math> местами и возобновить просмотр с начала массива. Когда не удастся найти такое <math><mi>i</mi></math>, массив будет упорядочен нужным образом. Написать программу, реализующую этот алгоритм.
</li> 
<li>Рассмотреть все алгоритмы сортировки, сформулированные в этом параграфе, и указать достоинства и недостатки каждого из них. Необходимо помнить, что в случае небольших массивов те алгоритмы, которые сформулированы в задаче 628, дают вполне удовлетворительное решение задачи. При больших <math><mi>n</mi></math> требуется тщательно изучить все особенности конкретной ситуации и, исходя из этого, подобрать алгоритм. Задачи сортировки массивов возникают не только в связи с числовыми массивами. Тип элемента может быть довольно сложным, и надо учитывать, во что обходится сравнение и перемещение элементов в том или ином случае.  
</li>
<li>Даны пять попарно различных чисел 
<math><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo>,</mo><mi>d</mi><mo>,</mo><mi>e</mi></math>. Упорядочить их по возрастанию, используя для этого не более семи сравнений.</li>
<li>Даны действительные числа 
<math>
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mi>n</mi></msub>
</math>. Получить попарно различные целые
<math><msub><mi>i</mi><mn>1</mn></msub><mo>,</mo><mi>&#133;</mi><mo>,</mo><msub><mi>i</mi><mn>n</mn></msub></math> такие, что
<math>
	<mi>1</mi><mo>&#8804;</mo><msub><mi>i</mi><mn>k</mn></msub><mo>&#8804;</mo><mi>n</mi><mo>,</mo>
	<mrow><mi>k</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>&#133;</mi><mo>,</mo><mi>n</mi></mrow>
</math> и
<math> 
	<msub><mi>a</mi><mi>i1</mi></msub><mo>&#8805;</mo>
	<msub><mi>a</mi><mi>i2</mi></msub><mo>&#8805;</mo>
	<mi>&#133;</mi><mo>&#8805;</mo>
	<msub><mi>a</mi><mi>in</mi></msub>
</math>.
</li>
<li>Даны натуральное число, <math><mi>n</mi></math> целые числа
<math> 
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mn>n</mn></msub>
</math>. Найти наибольшее значение, встречающееся в последовательности
<math> 
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mn>n</mn></msub>
</math> после выбрасывания из нее
<ol type='a'>
<li>одного из членов со значением 
<math><mi>max</mi><mo>&#x2061;</mo>
	<mrow>
		<mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>&#133;</mi><mo>,</mo><msub><mi>a</mi><mn>n</mn></msub><mo>)</mo>
	</mrow>
</math>;</li>
<li>всех членов со значением 
<math><mi>max</mi><mo>&#x2061;</mo>
	<mrow>
		<mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>&#133;</mi><mo>,</mo><msub><mi>a</mi><mn>n</mn></msub><mo>)</mo>
	</mrow>
</math> &#151; здесь предполагается, что не все числа 
<math> 
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mn>n</mn></msub>
</math> равны между собой.
</li>
</ol>
</li>
<li>Даны натуральное число <math><mi>n</mi></math> , действительные числа 
<math> 
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mn>n</mn></msub>
</math>. Требуется найти 
<math><mi>max</mi><mo>&#x2061;</mo>
	<mrow>
		<mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>&#133;</mi><mo>,</mo><msub><mi>a</mi><mn>n</mn></msub><mo>)</mo>
	</mrow>
</math> и
<math><mi>min</mi><mo>&#x2061;</mo>
	<mrow>
		<mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>&#133;</mi><mo>,</mo><msub><mi>a</mi><mn>n</mn></msub><mo>)</mo>
	</mrow>
</math>. Рассмотрим два алгоритма решения этой задачи. Первый алгоритм. Шаг за шагом получить пары 
<math>
	<mrow>	
		<mi>max</mi><mo>&#x2061;</mo>
		<mrow>
			<mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>&#133;</mi><mo>,</mo><msub><mi>a</mi><mn>i</mn></msub><mo>)</mo>
		</mrow>
	</mrow>
	<mo>,</mo>
	<mrow>	
		<mi>min</mi><mo>&#x2061;</mo>
		<mrow>
			<mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>&#133;</mi><mo>,</mo><msub><mi>a</mi><mn>i</mn></msub><mo>)</mo>
		</mrow>
	</mrow>
	<mo>,</mo>
	<mrow><mi>i</mi><mo>=</mo><mrow><mn>1</mn><mi>&#133;</mi><mi>n</mi></mrow></mrow>	
</math>. При этом, чтобы получить
<math>
	<mrow>	
		<mi>max</mi><mo>&#x2061;</mo>
		<mrow>
			<mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>&#133;</mi><mo>,</mo><msub><mi>a</mi><mrow><mn>i</mn><mo>+</mo><mn>1</mn></mrow></msub><mo>)</mo>
		</mrow>
	</mrow>
</math>,
<math>	
	<mrow>	
		<mi>min</mi><mo>&#x2061;</mo>
		<mrow>
			<mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>&#133;</mi><mo>,</mo><msub><mi>a</mi><mrow><mn>i</mn><mo>+</mo><mn>1</mn></mrow></msub><mo>)</mo>
		</mrow>
	</mrow>
</math>,
<math><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></math>
сравнивается с 
<math><mi>max</mi><mo>&#x2061;</mo>
	<mrow>
		<mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>&#133;</mi><mo>,</mo><msub><mi>a</mi><mi>n</mi></msub><mo>)</mo>
	</mrow>
</math>, а затем, если 
<math><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>&#60;</mo>
<mi>max</mi><mo>&#x2061;</mo>
	<mrow>
		<mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>&#133;</mi><mo>,</mo><msub><mi>a</mi><mi>n</mi></msub><mo>)</mo>
	</mrow>
</math>, 
<math><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></math>
дополнительно сравнивается с 
<math><mi>min</mi><mo>&#x2061;</mo>
	<mrow>
		<mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>&#133;</mi><mo>,</mo><msub><mi>a</mi><mn>n</mn></msub><mo>)</mo>
	</mrow>
</math>.
Второй алгоритм. Пусть <math> <mi>n</mi></math> - четное число, т. е. <math><mi>n</mi><mo>=</mo><mrow><mn>2</mn><mo>&#x2062;</mo><mi>k</mi></mrow></math>. Тогда шаг за шагом получать
<math>
	<mrow>	
		<mi>max</mi><mo>&#x2061;</mo>
		<mrow>
			<mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>&#133;</mi><mo>,</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&#x2062;</mo><mi>l</mi></mrow></msub><mo>)</mo>
		</mrow>
	</mrow>
	<mo>,</mo>
	<mrow>	
		<mi>min</mi><mo>&#x2061;</mo>
		<mrow>
			<mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>&#133;</mi><mo>,</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&#x2062;</mo><mi>l</mi></mrow></msub><mo>)</mo>
		</mrow>
	</mrow>
	<mo>,</mo>
	<mrow>
	<mi>l</mi><mo>=</mo><mrow><mn>1</mn><mo>,</mo><mi>&#133;</mi><mo>,</mo><mi>k</mi></mrow>
	</mrow>	
</math>.
При этом, чтобы получить
<math>
	<mrow>	
		<mi>max</mi><mo>&#x2061;</mo>
		<mrow>
			<mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>&#133;</mi><mo>,</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&#x2062;</mo><mi>l</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>)</mo>
		</mrow>
	</mrow>
	<mo>,</mo>
	<mrow>	
		<mi>min</mi><mo>&#x2061;</mo>
		<mrow>
			<mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>&#133;</mi><mo>,</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&#x2062;</mo><mi>l</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>)</mo>
		</mrow>
	</mrow>
</math>, вначале сравниваются между собой
<math>
	<msub><mi>a</mi><mrow><mn>2</mn><mo>&#x2062;</mo><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub>
	<mo>,</mo>
	<msub><mi>a</mi><mrow><mn>2</mn><mo>&#x2062;</mo><mi>l</mi><mo>+</mo><mn>2</mn></mrow></msub>
</math> и 
<math> 
	<mi>max</mi><mo>&#x2061;</mo>
	<mrow>
		<mo>(</mo>
			<msub><mi>a</mi><mrow><mn>2</mn><mo>&#x2062;</mo><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub>
			<mo>,</mo>
			<msub><mi>a</mi><mrow><mn>2</mn><mo>&#x2062;</mo><mi>l</mi><mo>+</mo><mn>2</mn></mrow></msub>
		<mo>)</mo>
	</mrow>
</math> сравнивается с 
<math>
	<mrow>	
		<mi>max</mi><mo>&#x2061;</mo>
		<mrow>
			<mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>&#133;</mi><mo>,</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&#x2062;</mo><mi>l</mi></mrow></msub><mo>)</mo>
		</mrow>
	</mrow>
</math>, а 
<math> 
	<mi>min</mi><mo>&#x2061;</mo>
	<mrow>
		<mo>(</mo>
			<msub><mi>a</mi><mrow><mn>2</mn><mo>&#x2062;</mo><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub>
			<mo>,</mo>
			<msub><mi>a</mi><mrow><mn>2</mn><mo>&#x2062;</mo><mi>l</mi><mo>+</mo><mn>2</mn></mrow></msub>
		<mo>)</mo>
	</mrow>
</math> &#151; с 
<math>
	<mrow>	
		<mi>min</mi><mo>&#x2061;</mo>
		<mrow>
			<mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>&#133;</mi><mo>,</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&#x2062;</mo><mi>l</mi></mrow></msub><mo>)</mo>
		</mrow>
	</mrow>
</math>.
Если <math><mi>n</mi></math> &#151; нечетное число, то потребуется еще дополнительный шаг: сравнение последнего элемента  
<math><msub><mi>a</mi><mi>n</mi></msub></math> с 
<math><mi>max</mi><mo>&#x2061;</mo>
	<mrow>
		<mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>&#133;</mi><mo>,</mo><msub><mi>a</mi><mrow><mn>n</mn><mo>-</mo><mn>1</mn></mrow></msub><mo>)</mo>
	</mrow>
</math>
 и, возможно, с
<math><mi>min</mi><mo>&#x2061;</mo>
	<mrow>
		<mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><mi>&#133;</mi><mo>,</mo><msub><mi>a</mi><mrow><mn>n</mn><mo>-</mo><mn>1</mn></mrow></msub><mo>)</mo>
	</mrow>
</math>. 
Сколько сравнений в худшем случае потребует первый алгоритм и сколько &#151; второй? Написать программу, реализующую второй алгоритм. (Заметим, что второй алгоритм дает еще одно решение задачи 230.) 
 </li>
<li>Даны натуральные числа
<math> 
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mn>n</mn></msub>
</math>.
Пусть
<math> 
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mn>n</mn></msub>
</math> &#151; перестановка чисел
<math><mn>1</mn><mo>,</mo><mi>&#133;</mi><mo>,</mo><mi>n</mi></math>.
Получить натуральные 
<math> 
	<msub><mi>r</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>r</mi><mn>n</mn></msub>
</math> такие, что
<math><msub><mi>r</mi><msub><mi>a</mi><mi>i</mi></msub></msub><mo>=</mo><mi>i</mi></math> для
<math><mi>i</mi>=<mn>1</mn><mo>,</mo><mi>&#133;</mi><mo>,</mo><mi>n</mi></math>.
</li>
<li>Решить задачи 646, 647, предполагая, что числа
<math> 
	<msub><mi>a</mi><mn>1</mn></msub>
	<mo>,</mo><mi>&#133;</mi><mo>,</mo>
	<msub><mi>a</mi><mn>n</mn></msub>
</math>
являются компонентами данного файла. При этом значение <math><mi>n</mi></math> заранее неизвестно. 
</li>
<li>Число компонент файла
 <math> <mi>f</mi></math>, компонентами которого являются целые числа, кратно десяти. Переписать компоненты файла <math> <mi>f</mi></math> в файл <math> <mi>g</mi></math>, изменяя порядок чисел в каждой десятке так, чтобы
 <ol>
<li>вначале шли отрицательные числа десятки, а за ними &#151; неотрицательные;</li>
<li>вначале шли числа, делящиеся на 3, затем числа, дающие при делении на 3 остаток 1, затем числа, дающие при делении на 3 остаток 2.</li>
 </ol>
Порядок самих десяток должен быть сохранен.
 </li>
 <li>Рассматриваются слова (см. задачу 269), содержащиеся в символьных файлах
<math><msub><mi>f</mi><mn>1</mn></msub></math> и <math><msub><mi>f</mi><mn>2</mn></msub></math>. Известно, что число символов в словах не превосходит шестнадцати. Известно также, что слова в файле <math><msub><mi>f</mi><mn>1</mn></msub></math> идут в лексикографическом порядке, и их число равно пятидесяти. Выяснить, сколько раз каждое из слов файла 
<math><msub><mi>f</mi><mn>2</mn></msub></math> встречается в файле <math><msub><mi>f</mi><mn>1</mn></msub></math>. Для решения задачи переписать слова, содержащиеся в файле 
<math><msub><mi>f</mi><mn>2</mn></msub></math>, в массив и последовательно применять метод деления пополам (см. задачу 631). 
 </li>
 <li>Пусть файлы  <math><mi>c</mi></math> и <math><mi>d</mi></math> с компонентами, являющимися действительными или целыми числами, упорядочены по невозрастанию компонент. Требуется собрать компоненты файлов <math> <mi>c</mi></math> и <math><mi>d</mi></math> в упорядоченном виде в файле <math><mi>f</mi></math> (ср. c задачей 635). Количество сравнений не должно превосходить <math><mi>p</mi><mo>+</mo><mi>g</mi></math>, где <math><mi>p</mi></math> и <math><mi>g</mi></math> &#151; число компонент в файлах <math><mi>c</mi></math> и <math><mi>d</mi></math>.</li>
<li>Пусть <math><mi>a</mi></math> и <math><mi>b</mi></math> &#151; файлы, <math><mi>k</mi></math> &#151; натуральное число. Будем говорить, что файлы 
<math><mi>a</mi></math> и <math><mi>b</mi></math> согласованно <math><mi>k</mi></math>-упорядочены, если
<ol type='1'>
<li>в каждом из файлов <math><mi>a</mi></math> и <math><mi>b</mi></math>  
первые <math><mi>k</mi></math> компонент, следующие за ними <math><mi>k</mi></math> компонент и т. д. образуют упорядоченные группы; последняя группа файла (тоже упорядоченная) может быть неполной, т. е. содержать менее <math> <mi>k</mi></math> компонент, но при этом только один из файлов <math><mi>a</mi></math> или <math><mi>b</mi></math> может иметь неполную последнюю группу; 
</li>
<li>число упорядоченных групп файла <math><mi>a</mi></math> отличается от числа упорядоченных групп файла <math><mi>b</mi></math> не более чем на единицу; 
</li>
<li>если в одном файле число упорядоченных групп меньше на единицу, чем в другом, то неполной может быть только последняя группа более длинного файла.
</li>
</ol>
<p>
Компоненты двух согласованно <math><mi>k</mi></math>-упорядоченных файлов <math><mi>a</mi></math> и <math><mi>b</mi></math> можно разместить в файлах <math><mi>g</mi></math> и <math><mi>h</mi></math> так, что <math><mi>g</mi></math> и <math><mi>h</mi></math> будут согласованно  <math><mn>2</mn><mo>&#x2062;</mo><mi>k</mi></math>-упорядочены. Это делается с помощью описанных в предыдущей задаче слияний; при этом результаты слияния попеременно размещаются то в файле <math><mi>g</mi></math>, то в файле <math><mi>h</mi></math>. Рисунок 35 демонстрирует происходящее при первых двух слияниях. Файлы представлены в виде отрезков, части которых изображают упорядоченные группы с указанным числом компонент. 
 Завершить описание этого алгоритма, рассмотрев его заключительную стадию. Доказать, что файлы <math><mi>g</mi></math> и <math><mi>h</mi></math> действительно будут согласованно <math> <mn>2</mn><mo>&#x2062;</mo><mi>k</mi></math>-упорядочены. Реализовать этот алгоритм в виде программы.</p>
 
<svg width="600" height="278">
<line y1='40' x1='40' y2='40' x2='260' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='37' x1='40' y2='43' x2='40' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='37' x1='140' y2='43' x2='140' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='37' x1='260' y2='43' x2='260' stroke-width="1" stroke="#000000" fill="none"/>
<text font-family="serif" font-size="14" y="45" x="265" stroke-width="0" stroke="#000000" fill="#000000">g</text>
<text font-family="serif" font-size="14" y="60" x="65" stroke-width="0" stroke="#000000" fill="#000000">2k</text>
 
<line y1='40' x1='300' y2='40' x2='520' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='37' x1='300' y2='43' x2='300' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='37' x1='400' y2='43' x2='400' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='37' x1='520' y2='43' x2='520' stroke-width="1" stroke="#000000" fill="none"/>
<text font-family="serif" font-size="14" y="45" x="525" stroke-width="0" stroke="#000000" fill="#000000">g</text>
<text font-family="serif" font-size="14" y="30" x="345" stroke-width="0" stroke="#000000" fill="#000000">2k</text> 
 
<line y1='90' x1='40' y2='90' x2='260' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='87' x1='40' y2='93' x2='40' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='87' x1='260' y2='93' x2='260' stroke-width="1" stroke="#000000" fill="none"/>
<text font-family="serif" font-size="14" y="95" x="265" stroke-width="0" stroke="#000000" fill="#000000">h</text>

<line y1='90' x1='300' y2='90' x2='520' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='87' x1='300' y2='93' x2='300' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='87' x1='400' y2='93' x2='400' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='87' x1='520' y2='93' x2='520' stroke-width="1" stroke="#000000" fill="none"/>
<text font-family="serif" font-size="14" y="95" x="525" stroke-width="0" stroke="#000000" fill="#000000">h</text>
<text font-family="serif" font-size="14" y="80" x="345" stroke-width="0" stroke="#000000" fill="#000000">2k</text>  

<line y1='140' x1='40' y2='140' x2='260' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='137' x1='40' y2='143' x2='40' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='137' x1='260' y2='143' x2='260' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='137' x1='90' y2='143' x2='90' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='137' x1='140' y2='143' x2='140' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='137' x1='190' y2='143' x2='190' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='137' x1='240' y2='143' x2='240' stroke-width="1" stroke="#000000" fill="none"/>
<text font-family="serif" font-size="14" y="160" x="60" stroke-width="0" stroke="#000000" fill="#000000">k</text>
<text font-family="serif" font-size="14" y="160" x="110" stroke-width="0" stroke="#000000" fill="#000000">k</text>
<text font-family="serif" font-size="14" y="160" x="160" stroke-width="0" stroke="#000000" fill="#000000">k</text>
<text font-family="serif" font-size="14" y="160" x="210" stroke-width="0" stroke="#000000" fill="#000000">k</text>
<text font-family="serif" font-size="14" y="145" x="265" stroke-width="0" stroke="#000000" fill="#000000">a</text>

<line y1='140' x1='300' y2='140' x2='520' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='137' x1='300' y2='143' x2='300' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='137' x1='520' y2='143' x2='520' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='137' x1='350' y2='143' x2='350' stroke-width="1" stroke="#000000" fill="none"/>

<line y1='137' x1='400' y2='143' x2='400' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='137' x1='450' y2='143' x2='450' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='137' x1='500' y2='143' x2='500' stroke-width="1" stroke="#000000" fill="none"/>
<text font-family="serif" font-size="14" y="160" x="320" stroke-width="0" stroke="#000000" fill="#000000">k</text>
<text font-family="serif" font-size="14" y="160" x="370" stroke-width="0" stroke="#000000" fill="#000000">k</text>
<text font-family="serif" font-size="14" y="160" x="420" stroke-width="0" stroke="#000000" fill="#000000">k</text>
<text font-family="serif" font-size="14" y="160" x="470" stroke-width="0" stroke="#000000" fill="#000000">k</text>
<text font-family="serif" font-size="14" y="145" x="525" stroke-width="0" stroke="#000000" fill="#000000">a</text>

<line y1='190' x1='40' y2='190' x2='240' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='187' x1='40' y2='193' x2='40' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='187' x1='240' y2='193' x2='240' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='187' x1='90' y2='193' x2='90' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='187' x1='140' y2='193' x2='140' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='187' x1='190' y2='193' x2='190' stroke-width="1" stroke="#000000" fill="none"/>
<text font-family="serif" font-size="14" y="210" x="60" stroke-width="0" stroke="#000000" fill="#000000">k</text>
<text font-family="serif" font-size="14" y="210" x="110" stroke-width="0" stroke="#000000" fill="#000000">k</text>
<text font-family="serif" font-size="14" y="210" x="160" stroke-width="0" stroke="#000000" fill="#000000">k</text>
<text font-family="serif" font-size="14" y="210" x="210" stroke-width="0" stroke="#000000" fill="#000000">k</text>
<text font-family="serif" font-size="14" y="195" x="245" stroke-width="0" stroke="#000000" fill="#000000">b</text>


<line y1='190' x1='300' y2='190' x2='500' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='187' x1='300' y2='193' x2='300' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='187' x1='500' y2='193' x2='500' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='187' x1='350' y2='193' x2='350' stroke-width="1" stroke="#000000" fill="none"/>

<line y1='187' x1='400' y2='193' x2='400' stroke-width="1" stroke="#000000" fill="none"/>
<line y1='187' x1='450' y2='193' x2='450' stroke-width="1" stroke="#000000" fill="none"/>
<text font-family="serif" font-size="14" y="210" x="320" stroke-width="0" stroke="#000000" fill="#000000">k</text>
<text font-family="serif" font-size="14" y="210" x="370" stroke-width="0" stroke="#000000" fill="#000000">k</text>
<text font-family="serif" font-size="14" y="210" x="420" stroke-width="0" stroke="#000000" fill="#000000">k</text>
<text font-family="serif" font-size="14" y="210" x="470" stroke-width="0" stroke="#000000" fill="#000000">k</text>
<text font-family="serif" font-size="14" y="195" x="510" stroke-width="0" stroke="#000000" fill="#000000">b</text>

<text font-family="serif" font-size="14" y="254" x="230" stroke-width="0" stroke="#000000" fill="#000000">Рис. 35</text>

<path stroke="#000000" fill="none" d="M40,135 C45,130 60,132 65,125 C70,132 85,130 90,135"/>

<path stroke="#000000" fill="none" d="M40,185 C45,180 60,182 65,175 C70,182 85,180 90,185"/>

<path stroke="#000000" fill="none" d="M350,185 C355,180 370,182 375,175 C380,182 395,180 400,185"/>

<path stroke="#000000" fill="none" d="M350,135 C355,130 370,132 375,125 C380,132 395,130 400,135"/>

<path stroke="#000000" fill="none" d="M310,127 A30,35 20 1,1 340,70"/>

<path stroke="#000000" fill="none" d="M360,175 L290,160 285,103"/>

<path stroke="#000000" fill="none" d="M335,69 L340,70 340,65"/>

<path stroke="#000000" fill="none" d="M310,127 L355,127"/>

<path stroke="#000000" fill="none" d="M30,170 A25,80 5 1,1 60,35"/>

<path stroke="#000000" fill="none" d="M56,32 L60,35 62,30"/>

<path stroke="#000000" fill="none" d="M65,172 L30,170"/>

<path stroke="#000000" fill="none" d="M65,122 L12,110"/>
 </svg>
</li>
<li>Для сортировки файла <math><mi>g</mi></math> может быть применен следующий алгоритм. Пусть <math><mi>h</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>b</mi></math> &#151; вспомогательные файлы. Прежде всего, компоненты файла <math><mi>g</mi></math> распределяются по файлам <math><mi>a</mi><mo>,</mo><mi>b</mi></math>: компоненты с четными номерами попадают в  <math> <mi>a</mi></math>, а компоненты с нечетными номерами &#151; в <math><mi>b</mi></math>. Эти компоненты рассматриваются как упорядоченные группы, по одной компоненте в каждой, а файлы <math> <mi>a</mi><mo>,</mo><mi>b</mi></math> &#151; как согласованно 1-упорядоченные (см. предыдущую задачу). Затем с помощью алгоритма, описанного в предыдущей задаче, файлы <math> <mi>g</mi></math> и <math> <mi>h</mi></math> превращаются в согласованно 2-упорядоченные и т. д. Так как число упорядоченных групп убывает с каждым применением предложенного в предыдущей задаче алгоритма, то настанет такой момент, когда все компоненты соберутся в некотором файле в виде одной упорядоченной группы; на этом упорядочение будет закончено.
 Этот алгоритм очень похож на алгоритм фон Неймана для массивов (см. задачу 636) и тоже относится к алгоритмам сортировки слияниями.
 Реализовать этот алгоритм в виде программы.
</li>
<li>Пусть файлы <math><mi>a</mi></math> и <math><mi>b</mi></math>, компоненты которых являются целыми числами, упорядочены по неубыванию. Получить в файле <math><mi>c</mi></math> все числа файлов <math><mi>a</mi></math> и <math><mi>b</mi></math> без повторений. Файл <math><mi>c</mi></math> должен быть упорядочен по возрастанию.
 </li>
 <li>Дан файл <math><mi>f</mi></math>, компоненты которого являются целыми числами. Получить в файле <math><mi>g</mi></math> все нечетные числа, входящие в файл <math><mi>f</mi></math>. Числа в файле <math><mi>g</mi></math> должны следовать:
 <ol type='a'>
 <li>в порядке невозрастания;</li>
 <li>в порядке убывания, без повторений.</li>
 </ol>
 </li> 
 <li>Дан символьный файл <math><mi>f</mi></math>, компоненты которого &#151; малые латинские буквы и пробелы. Слова (см. задачу 269) файла <math><mi>f</mi></math> имеют не более шестнадцати букв. Записать эти слова в файл <math><mi>g</mi></math> в лексикографическом порядке.</li>
</ol>
</body> 
</html>