<!DOCTYPE html>
<html>
<head>
<meta charset='UTF-8' />
<link rel='stylesheet' type='text/css' href='style.css' />
<meta name='author' content='leonid' />
<title>Алгоритмы сортировки</title>
</head>
<body>
<p><a href="8_9_9.html">К предыдущему</a> <a href="index.html">К содержанию</a> <a href="8_10_2.html">К следующему</a> </p>
<h2>8.10. Алгоритмы сортировки</h2>
<p>Под сортировкой понимают перестановку элементов некоторого множества в определенном порядке. Цель сортировки состоит в ускорении процесса поиска элементов в отсортированном множестве. Следовательно, методы сортировки очень важны, особенно при обработке данных.</p>
<p>Алгоритмов сортировки очень много, и при выборе наиболее эффективного метода сортировки учитывают учитывают структуру данных.Зависимость метода сортировки от структуры данных настолько сильна, что методы сортировки обычно разделяют на два больших класса: сортировку массивов и сортировку файлов. Сортировку массивов называют внутренней сортировкой, так как массивы располагаются в оперативной памяти компьютера. Файлы хранятся в более медленной, но более вместительной внешней памяти, и сортировку файлов называют внешней сортировкой. Доступ к элементам массива произвольный, тогда как к файлам &#151; последовательный (в каждый момент времени доступен только один открытый файл). По этой причине алгоритмы внутренней и внешней сортировки существенно различаются.</p>
<p>Пусть есть последовательность 
<math>
	<mfenced open='' close=''>
		<msub><mi>a</mi><mn>0</mn></msub>
		<msub><mi>a</mi><mn>1</mn></msub>
		<mi>&#133;</mi>
		<msub><mi>a</mi><mi>n</mi></msub>
	</mfenced>
</math> и функция сравнения <math><mi>f</mi></math>, для которой на любых двух элементах <math><msub><mi>a</mi><mi>i</mi></msub></math> и <math><msub><mi>a</mi><mi>j</mi></msub></math> последовательности выполняется одно из трех соотношений: 
<math>
<mrow>
	<mrow>
		<mi>f</mi><mo>&#x2061;</mo><mrow><mo>(</mo><msub><mi>a</mi><mi>i</mi></msub><mo>)</mo></mrow>
	</mrow>
	<mo>&lt;</mo>
	<mrow>
		<mi>f</mi><mo>&#x2061;</mo><mrow><mo>(</mo><msub><mi>a</mi><mi>j</mi></msub><mo>)</mo></mrow>
	</mrow>
</mrow>
<mo>,</mo>
<mrow>
	<mrow>
		<mi>f</mi><mo>&#x2061;</mo><mrow><mo>(</mo><msub><mi>a</mi><mi>i</mi></msub><mo>)</mo></mrow>
	</mrow>
	<mo>=</mo>
	<mrow>
		<mi>f</mi><mo>&#x2061;</mo><mrow><mo>(</mo><msub><mi>a</mi><mi>j</mi></msub><mo>)</mo></mrow>
	</mrow>
</mrow>	
<mo>,</mo>
<mrow>
	<mrow>
		<mi>f</mi><mo>&#x2061;</mo><mrow><mo>(</mo><msub><mi>a</mi><mi>i</mi></msub><mo>)</mo></mrow>
	</mrow>
	<mo>&gt;</mo>
	<mrow>
		<mi>f</mi><mo>&#x2061;</mo><mrow><mo>(</mo><msub><mi>a</mi><mi>j</mi></msub><mo>)</mo></mrow>
	</mrow>
</mrow>
<mo>.</mo>
</math> Задача сортировки последовательности элементов по возрастанию функции сравнения <math><mi>f</mi></math>  состоит в перестановке членов последовательности таким образом, чтобы выполнялось условие 
<math>
<mrow>
	<mrow>
		<mi>f</mi><mo>&#x2061;</mo><mrow><mo>(</mo><msub><mi>a</mi><mi>i</mi></msub><mo>)</mo></mrow>
	</mrow>
	<mo>&#8804;</mo>
	<mrow>
		<mi>f</mi><mo>&#x2061;</mo><mrow><mo>(</mo><msub><mi>a</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn><mrow></msub><mo>)</mo></mrow>
	</mrow>
</mrow>
</math> для всех <math><mi>i</mi></math> от <math><mn>0</mn></math> до <math><mi>n</mi><mo>-</mo><mn>1</mn></math>.</p>
<p>Возможна ситуация, когда элементы последовательности состоят из нескольких полей, например, <math><mi>x</mi></math> и <math><mi>y</mi></math>. Если значение функции сравнения зависит только от поля <math><mi>x</mi></math>, то <math><mi>x</mi></math> называют ключом, по которому производится сортировка. На практике в качестве <math><mi>x</mi></math> часто выступает число, а поле <math><mi>y</mi></math> хранит какие-либо данные, никак не влияющие на работу алгоритма. В этом случае в качестве значения функции <math><mi>f</mi></math>, к примеру, можно выбрать <math><mi>x</mi></math>.</p>
<p>Существует множество алгоритмов сортировки элементов последовательности, и их эффективность оценивается по нескольким параметрам:
<ul>
<li>временной сложности &#151; основному параметру, характеризующему быстродействие алгоритма;</li>
<li>пространственной сложности &#151; занимаемой памяти. Ряд алгоритмов требует выделения дополнительной памяти под временное хранение данных. При оценке используемой памяти не будет учитываться место, которое занимает исходный массив и независящие от входной последовательности затраты, например, на хранение кода программы;</li>
<li>устойчивости &#151; устойчивая сортировка не меняет взаимного расположения элементов с одинаковыми ключами. Такое свойство может быть очень полезным, если элементы состоят из нескольких полей, а сортировка происходит по одному из них, например, по <math><mi>x</mi></math>.</li>
<li>естественности поведения &#151; эффективность метода при обработке уже отсортированных или частично отсортированных данных. Алгоритм ведет себя естественно, если учитывает эту характеристику входной последовательности.</li>
</ul>
</p>
<p>Пример. Пусть исходная последовательность такая:
<math>
<mfenced open='{' close='}'>
<mrow><mo>(</mo><mi>a</mi><mo>,</mo><mn>1</mn><mo>)</mo></mrow>
<mrow><mo>(</mo><mi>q</mi><mo>,</mo><mn>3</mn><mo>)</mo></mrow>
<mrow><mo>(</mo><mi>b</mi><mo>,</mo><mn>1</mn><mo>)</mo></mrow>
<mrow><mo>(</mo><mi>c</mi><mo>,</mo><mn>1</mn><mo>)</mo></mrow>
<mrow><mo>(</mo><mi>z</mi><mo>,</mo><mn>2</mn><mo>)</mo></mrow>
</mfenced><mo>,</mo>
</math>
а отсортированная по возрастанию числового поля последовательность выглядит так:
<math>
<mfenced open='{' close='}'>
<mrow><mo>(</mo><mi>a</mi><mo>,</mo><mn>1</mn><mo>)</mo></mrow>
<mrow><mo>(</mo><mi>b</mi><mo>,</mo><mn>1</mn><mo>)</mo></mrow>
<mrow><mo>(</mo><mi>c</mi><mo>,</mo><mn>1</mn><mo>)</mo></mrow>
<mrow><mo>(</mo><mi>z</mi><mo>,</mo><mn>2</mn><mo>)</mo></mrow>
<mrow><mo>(</mo><mi>q</mi><mo>,</mo><mn>3</mn><mo>)</mo></mrow>
</mfenced><mo>.</mo>
</math> Сортировка устойчивая, так как взаимное расположение элементов
<math>
<mfenced open='' close=''>
<mrow><mo>(</mo><mi>a</mi><mo>,</mo><mn>1</mn><mo>)</mo></mrow>
<mrow><mo>(</mo><mi>b</mi><mo>,</mo><mn>1</mn><mo>)</mo></mrow>
<mrow><mo>(</mo><mi>c</mi><mo>,</mo><mn>1</mn><mo>)</mo></mrow>
</mfenced>
</math>
 с ключом 1 не изменилось. Если же отсортированная последовательность будет такой:
<math>
<mfenced open='{' close='}'>
<mrow><mo>(</mo><mi>a</mi><mo>,</mo><mn>1</mn><mo>)</mo></mrow>
<mrow><mo>(</mo><mi>c</mi><mo>,</mo><mn>1</mn><mo>)</mo></mrow>
<mrow><mo>(</mo><mi>b</mi><mo>,</mo><mn>1</mn><mo>)</mo></mrow>
<mrow><mo>(</mo><mi>z</mi><mo>,</mo><mn>2</mn><mo>)</mo></mrow>
<mrow><mo>(</mo><mi>q</mi><mo>,</mo><mn>3</mn><mo>)</mo></mrow>
</mfenced><mo>,</mo>
</math> то алгоритм сортировки неустойчивый &#151; изменилось взаимное расположение элементов
<math>
<mrow><mo>(</mo><mi>b</mi><mo>,</mo><mn>1</mn><mo>)</mo></mrow>
</math>
 и
<math>
<mrow><mo>(</mo><mi>c</mi><mo>,</mo><mn>1</mn><mo>)</mo></mrow>
<mo>.</mo>
</math>
</p>
<p>Основное требование к методам сортировки массивов заключается в экономном использовании памяти &#151; для сортировки массива следует избегать пересылки элементов из массива в массив. Следующее требование к методам сортировки &#151; их быстродействие. Для оценки быстродействия алгоритма используют количество <math><mi>C</mi></math> необходимых операций сравнения (compare) элементов и количество <math><mi>M</mi></math> операций перемещения (move) элементов. Эти величины являются некоторыми функциями от количества <math><mi>n</mi></math> элементов массива. Наиболее простые методы сортировки массивов требуют порядка <math><msup><mi>n</mi><mn>2</mn></msup></math> операций сравнения, а наиболее быстрые &#151; порядка  <math><mi>n</mi><mo>&#x2062;</mo><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>&#x2061;</mo><mi>n</mi></mrow></math>.</p>
<p>Следует заметить, что простые методы сортировки при малых <math><mi>n</mi></math> более эффективны, ни при больших значениях <math><mi>n</mi></math> их не рекомендуют использовать.</p>
<p>Далее рассмотрим три основных класса сортировки массивов:
<ol>
<li>Сортировку включениями;</li>
<li>сортировку выбором;</li>
<li>сортировку обменом.</li>
</ol>
</p>
<p><a href="8_9_9.html">К предыдущему</a> <a href="index.html">К содержанию</a> <a href="8_10_2.html">К следующему</a> </p>
</body>
</html>